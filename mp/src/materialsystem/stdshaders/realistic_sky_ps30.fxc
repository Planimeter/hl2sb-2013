#include "common_ps_fxc.h"
//Adapted from https://www.shadertoy.com/view/llSSDR

#define PI 3.1415926535897932384626433832795

const float4 g_SunDir   : register(c0);
const float4 g_Exposure : register(c1);
const float4 g_turbidity : register(c2);

// Define pixel shader input structure
struct PS_INPUT
{
    float3 viewDir : TEXCOORD0;   // Normalized view direction (from vertex shader)
};

float3 calculatePerezLuminanceYxy( in float theta, in float gamma, in float3 A, in float3 B, in float3 C, in float3 D, in float3 E )
{
	return ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );
}

float3 calculateZenithLuminanceYxy( in float t, in float thetaS )
{
	float chi  	 	= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );
	float Yz   	 	= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;

	float theta2 	= thetaS * thetaS;
    float theta3 	= theta2 * thetaS;
    float T 	 	= t;
    float T2 	 	= t * t;

	float xz =
      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +
      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +
      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);

    float yz =
      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +
      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +
      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);

	return float3( Yz, xz, yz );
}


void calculatePerezDistribution( in float t, out float3 A, out float3 B, out float3 C, out float3 D, out float3 E )
{
	A = float3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );
	B = float3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );
	C = float3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );
	D = float3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );
	E = float3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );
}

float saturatedDot( in float3 a, in float3 b )
{
	return max( dot( a, b ), 0.0 );   
}

float3 YxyToXYZ( in float3 Yxy )
{
	float Y = Yxy.r;
	float x = Yxy.g;
	float y = Yxy.b;

	float X = x * ( Y / y );
	float Z = ( 1.0 - x - y ) * ( Y / y );

	return float3(X,Y,Z);
}

float3 XYZToRGB(float3 XYZ)
{
    // Define the transformation matrix (row-major order for HLSL)
    float3x3 M = float3x3(
         2.3706743, -0.5138850,  0.0052982,   // Row 1
        -0.9000405,  1.4253036, -0.0146949,   // Row 2
        -0.4706338,  0.0885814,  1.0093968    // Row 3
    );

    // Perform matrix multiplication
    return mul(XYZ, M);
}

float3 LinearToSRGB(float3 linearRGB)
{
    float3 sRGB;
    sRGB = (linearRGB <= 0.0031308) ? 
        (12.92 * linearRGB) : 
        (1.055 * pow(linearRGB, 1.0 / 2.4) - 0.055);
    return sRGB;
}



float3 YxyToRGB( in float3 Yxy )
{
	float3 XYZ = YxyToXYZ( Yxy );
	float3 RGB = XYZToRGB( XYZ );
	return RGB;
}


float3 calculateSkyLuminanceRGB( in float3 s, in float3 e, in float t )
{
	float3 A, B, C, D, E;
	calculatePerezDistribution( t, A, B, C, D, E );

	float thetaS = acos( saturatedDot( s, float3(0,1,0) ) );
	float thetaE = acos( saturatedDot( e, float3(0,1,0) ) );
	float gammaE = acos( saturatedDot( s, e )		   );

	float3 Yz = calculateZenithLuminanceYxy( t, thetaS );

	float3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );
	float3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );

	float3 Yp = Yz * ( fThetaGamma / fZeroThetaS );

	return YxyToRGB( Yp );
}


float4 main(PS_INPUT i) : COLOR
{
    float3 dir = normalize(i.viewDir);
    
    float3 dirYUp = float3(dir.x, dir.z, -dir.y); // Transformed to Y-up

    float3 skyLuminance = calculateSkyLuminanceRGB( g_SunDir, dirYUp, g_turbidity );

    float scale = max(1.0/g_Exposure,0);
    skyLuminance*=scale;

    float4 result = float4 (skyLuminance, 1.0f);

    return FinalOutput(result, 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_LINEAR , 0, 1e20);
}